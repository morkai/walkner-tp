// Part of <https://miracle.systems/p/walkner-wmes> licensed under <CC BY-NC-SA 4.0>

'use strict';

const _ = require('lodash');
const pubsub = require('h5.pubsub');

exports.DEFAULT_CONFIG = {
  sioId: 'sio',
  statsPublishInterval: 60000,
  publishBatchSize: Number.MAX_SAFE_INTEGER,
  republishMaxDelay: 10,
  republishTopics: []
};

exports.onModuleSetUp = (app, {module, setUpAppModule}) =>
{
  (setUpAppModule.republishTopics || []).forEach(topic => module.config.republishTopics.push(topic));
};

exports.start = (app, module) =>
{
  const stats = {
    publishedMessages: 0,
    receivedMessages: 0,
    sentMessages: 0,
    ignoredEchoes: 0,
    ignoredDuplications: 0,
    totalSubscriptions: 0,
    currentSubscriptions: 0,
    unsubscriptions: 0
  };

  /**
   * @type {number}
   */
  let sendingMessages = 0;

  /**
   * @type {number}
   */
  let nextMessageId = 0;

  /**
   * @type {object.<string, Array>}
   */
  let idToMessageMap = {};

  /**
   * @type {object.<string, object.<string, boolean>>}
   */
  let socketIdToMessagesMap = {};

  /**
   * @type {RegExp}
   */
  const invalidTopicRegExp = /^(\s*|\s*\.\s*)+$/;

  /**
   * @type {WeakSet<object>}
   */
  const metaDups = new WeakSet();

  /**
   * @type {function()}
   */
  const scheduleSendMessages = _.debounce(sendMessages, module.config.republishMaxDelay, {
    trailing: true,
    leading: false
  });

  /**
   * @type {MessageBroker}
   */
  module = app[module.name] = Object.assign(new pubsub.MessageBroker(), module);

  module.config.republishTopics.forEach((topic) =>
  {
    app.broker.subscribe(topic, (message, topic, meta) =>
    {
      if (metaDups.has(meta))
      {
        return;
      }

      metaDups.add(meta);

      module.publish(topic, message, {
        json: meta.json,
        messageId: meta.messageId
      });
    });
  });

  module.on('message', (topic, message, meta) =>
  {
    if (stats.currentSubscriptions === 0)
    {
      return;
    }

    ++stats.publishedMessages;

    if (typeof meta.messageId === 'undefined')
    {
      meta.messageId = getNextMessageId();
    }

    idToMessageMap[meta.messageId] = {
      topic,
      payload: meta.json ? null : message,
      meta,
      json: meta.json ? wrapJsonMessage(topic, message, meta) : null,
      binary: null
    };

    scheduleSendMessages();
  });

  module.on('subscribe', () =>
  {
    ++stats.totalSubscriptions;
    ++stats.currentSubscriptions;
  });

  module.on('cancel', () =>
  {
    --stats.currentSubscriptions;
    ++stats.unsubscriptions;
  });

  app.onModuleReady(module.config.sioId, () =>
  {
    app[module.config.sioId].sockets.on('connection', (socket) =>
    {
      socket.pubsub = module.sandbox();
      socket.pubsub.onSubscriptionMessage = onSubscriptionMessage.bind(null, socket);

      socket.on('disconnect', onSocketDisconnect);
      socket.on('pubsub.subscribe', onSocketSubscribe);
      socket.on('pubsub.unsubscribe', onSocketUnsubscribe);
      socket.on('pubsub.publish', onSocketPublish);
    });
  });

  publishPubsubStats();

  function publishPubsubStats()
  {
    const interval = module.config.statsPublishInterval;

    if (interval <= 0)
    {
      return;
    }

    module.publish('stats.pubsub', stats);

    setTimeout(publishPubsubStats, interval);
  }

  function onSocketDisconnect()
  {
    const socket = this;

    delete socketIdToMessagesMap[socket.id];

    if (socket.pubsub)
    {
      socket.pubsub.destroy();
      socket.pubsub.onSubscriptionMessage = null;
      socket.pubsub = null;
    }
  }

  /**
   * @param {Array.<string>} topics
   * @param {function} [cb]
   */
  function onSocketSubscribe(topics, cb)
  {
    const hasCb = typeof cb === 'function';

    if (!Array.isArray(topics))
    {
      if (hasCb)
      {
        cb(app.createError(`First argument must be an array of topics.`, 'INPUT', 400));
      }

      return;
    }

    const socket = this;
    const pubsub = socket.pubsub;

    if (!pubsub)
    {
      return;
    }

    const notAllowedTopics = [];

    for (let i = 0, l = topics.length; i < l; ++i)
    {
      const topic = topics[i];

      if (isValidTopic(topic) && isSocketAllowedToSubscribe(socket, topic))
      {
        pubsub.subscribe(topic, pubsub.onSubscriptionMessage);
      }
      else
      {
        notAllowedTopics.push(topic);
      }
    }

    if (hasCb)
    {
      cb(null, notAllowedTopics);
    }
  }

  /**
   * @param {Array.<string>} topics
   */
  function onSocketUnsubscribe(topics)
  {
    if (!Array.isArray(topics))
    {
      return;
    }

    const socket = this;
    const pubsub = socket.pubsub;

    if (!pubsub)
    {
      return;
    }

    for (let i = 0, l = topics.length; i < l; ++i)
    {
      const topic = topics[i];

      if (isValidTopic(topic))
      {
        pubsub.unsubscribe(topic);
      }
    }
  }

  /**
   * @param {string} topic
   * @param {*} message
   * @param {Object} meta
   * @param {function} [cb]
   */
  function onSocketPublish(topic, message, meta, cb)
  {
    const socket = this;

    if (!socket.pubsub)
    {
      if (typeof cb === 'function')
      {
        cb();
      }

      return;
    }

    ++stats.receivedMessages;

    meta.socketId = socket.id;

    socket.pubsub.publish(topic, message, meta);

    if (typeof cb === 'function')
    {
      cb();
    }
  }

  /**
   * @param {Socket} socket
   * @param {*} message
   * @param {string} topic
   * @param {Object} meta
   */
  function onSubscriptionMessage(socket, message, topic, meta)
  {
    if (meta.socketId === socket.id)
    {
      ++stats.ignoredEchoes;

      return;
    }

    let socketMessagesMap = socketIdToMessagesMap[socket.id];

    if (!socketMessagesMap)
    {
      socketMessagesMap = socketIdToMessagesMap[socket.id] = {};
    }

    if (socketMessagesMap[meta.messageId])
    {
      ++stats.ignoredDuplications;

      return;
    }

    socketMessagesMap[meta.messageId] = true;
  }

  function sendMessages()
  {
    sendingMessages += 1;

    if (sendingMessages !== 1)
    {
      return;
    }

    const socketIds = Object.keys(socketIdToMessagesMap);

    if (socketIds.length === 0)
    {
      sendingMessages = 0;

      return;
    }

    sendMessageBatch(socketIdToMessagesMap, idToMessageMap, socketIds, 0);

    socketIdToMessagesMap = {};
    idToMessageMap = {};
  }

  function sendMessageBatch(socketIdToMessagesMap, idToMessageMap, socketIds, socketI)
  {
    const sockets = app[module.config.sioId].sockets.connected;
    let sentMessages = 0;

    while (socketI < socketIds.length && sentMessages <= module.config.publishBatchSize)
    {
      const socketId = socketIds[socketI++];
      const socket = sockets[socketId];

      if (socket === undefined)
      {
        continue;
      }

      const {binary} = socket.handshake;
      const socketMessagesMap = socketIdToMessagesMap[socketId];
      const messageIds = Object.keys(socketMessagesMap);

      for (let j = 0, m = messageIds.length; j < m; ++j)
      {
        const messageId = messageIds[j];
        const message = idToMessageMap[messageId];
        const socketMessage = resolveMessage(binary, message);

        socket.emit('pubsub.message', socketMessage);

        sentMessages += 1;
      }
    }

    stats.sentMessages += sentMessages;

    if (socketI < socketIds.length)
    {
      setImmediate(sendMessageBatch, socketIdToMessagesMap, idToMessageMap, socketIds, socketI);
    }
    else if (sendingMessages > 1)
    {
      sendingMessages = 0;

      setImmediate(sendMessages);
    }
    else
    {
      sendingMessages = 0;
    }
  }

  function resolveMessage(binary, message)
  {
    if (binary)
    {
      return resolveBinaryMessage(message);
    }

    return resolveJsonMessage(message);
  }

  function resolveJsonMessage(message)
  {
    if (message.json === null)
    {
      message.json = JSON.stringify([message.topic, message.payload, message.meta]);
    }

    return message.json;
  }

  function resolveBinaryMessage(message)
  {
    if (message.binary === null)
    {
      message.binary = Buffer.from(resolveJsonMessage(message), 'utf8');
    }

    return message.binary;
  }

  function wrapJsonMessage(topic, payload, meta)
  {
    return `["${topic}",${payload},${JSON.stringify(meta)}]`;
  }

  /**
   * @param {string} topic
   * @returns {boolean}
   */
  function isValidTopic(topic)
  {
    return typeof topic === 'string'
      && topic.length > 0
      && invalidTopicRegExp.test(topic) === false;
  }

  /**
   * @param {Socket} socket
   * @param {string} topic
   * @returns {boolean}
   */
  function isSocketAllowedToSubscribe(socket, topic) // eslint-disable-line no-unused-vars
  {
    return true;
  }

  /**
   * @returns {string}
   */
  function getNextMessageId()
  {
    ++nextMessageId;

    if (nextMessageId === 0xFFFFFFFF)
    {
      nextMessageId = 1;
    }

    return nextMessageId.toString(36);
  }
};
