// Part of <https://miracle.systems/p/walkner-wmes> licensed under <CC BY-NC-SA 4.0>

'use strict';

const mongoose = require('mongoose');
const expressMiddleware = require('./expressMiddleware');

exports.DEFAULT_CONFIG = {
  maxConnectTries: 10,
  connectAttemptDelay: 500,
  uri: 'mongodb://localhost/test',
  mongoClient: {},
  models: null,
  keepAliveQueryInterval: 30000,
  stopOnConnectError: true
};

exports.onModuleSetUp = (app, {module, setUpModule, setUpAppModule}) =>
{
  if (setUpAppModule.models && typeof setUpAppModule.models === 'object')
  {
    if (!module.modelsToLoad)
    {
      module.modelsToLoad = [];
    }

    module.modelsToLoad.push({
      setUpModule,
      setUpModels: setUpAppModule.models
    });
  }

  if (setUpAppModule.modelPlugins && typeof setUpAppModule.modelPlugins === 'object')
  {
    if (!module.modelPlugins)
    {
      module.modelPlugins = [];
    }

    module.modelPlugins.push({
      setUpModule,
      setUpPlugins: setUpAppModule.modelPlugins
    });
  }
};

exports.start = (app, module, done) =>
{
  const dev = app.options.env === 'development';
  const queryCounter = {total: 0};
  let keepAliveFailed = false;
  let initialized = false;

  mongoose.Schema.Types.Array.checkRequired(v => Array.isArray(v) && v.length);

  module = app[module.name] = Object.assign(mongoose, module);

  module.Promise = global.Promise;

  module.set('objectIdGetter', false);
  module.set('strict', true);
  module.set('strictQuery', true);

  module.set('debug', function(collectionName, methodName)
  {
    if (!queryCounter[collectionName])
    {
      queryCounter[collectionName] = {total: 0};
    }

    if (!queryCounter[collectionName][methodName])
    {
      queryCounter[collectionName][methodName] = 0;
    }

    queryCounter.total += 1;
    queryCounter[collectionName].total += 1;
    queryCounter[collectionName][methodName] += 1;

    if (dev && queryCounter.total % 1000 === 0)
    {
      dumpQueryCounter();
    }
  });

  module.connection.on('connecting', () => module.info('Connecting...'));
  module.connection.on('connected', () => module.info('Connected.'));
  module.connection.on('open', () => module.info('Open.'));
  module.connection.on('reconnected', () => module.info('Reconnected.'));
  module.connection.on('disconnecting', () => module.warn('Disconnecting...'));
  module.connection.on('disconnected', () => module.warn('Disconnected.'));
  module.connection.on('close', () => module.warn('Closed.'));
  module.connection.on('unauthorized', () => module.warn('Unauthorized.'));
  module.connection.on('error', (err) => module.error(err));

  app.broker.subscribe('app.started', onAppStarted).setLimit(1);
  app.broker.subscribe('express.beforeMiddleware', setUpExpressMiddleware).setLimit(1);

  tryToConnect(0);

  /**
   * @private
   * @param {number} i
   */
  function tryToConnect(i)
  {
    if (module.connection.readyState === mongoose.Connection.STATES.connected
      || module.connection.readyState === mongoose.Connection.STATES.connecting)
    {
      return;
    }

    module.connect(module.config.uri, module.config.mongoClient)
      .then(() => initialize())
      .catch(err =>
      {
        if (i >= module.config.maxConnectTries)
        {
          initialize(err);

          return;
        }

        if (err)
        {
          module.error(err);
        }

        setTimeout(tryToConnect.bind(null, i + 1), module.config.connectAttemptDelay);
      });
  }

  function initialize(err)
  {
    if (err)
    {
      if (module.config.stopOnConnectError)
      {
        return done(err);
      }

      module.error(err);

      setTimeout(tryToConnect, 10000, 0);
    }

    if (!initialized)
    {
      initialized = true;

      loadModels();
    }
  }

  /**
   * @private
   */
  function loadModels()
  {
    module.debug(`Loading models...`);

    if (!module.modelPlugins)
    {
      module.modelPlugins = [];
    }

    if (!module.modelsToLoad)
    {
      module.modelsToLoad = [];
    }

    const nameToPlugins = {
      '*': []
    };
    const uniquePlugins = {
      '*': new Set()
    };

    module.modelPlugins.forEach(({setUpModule, setUpPlugins}) =>
    {
      if (Array.isArray(setUpPlugins))
      {
        setUpPlugins.forEach(setUpPlugin =>
        {
          if (uniquePlugins['*'].has(setUpPlugin))
          {
            return;
          }

          nameToPlugins['*'].push(setUpPlugin.bind(null, app, setUpModule));
          uniquePlugins['*'].add(setUpPlugin);
        });
      }
      else
      {
        Object.keys(setUpPlugins).forEach(schemaName =>
        {
          if (!nameToPlugins[schemaName])
          {
            nameToPlugins[schemaName] = [];
            uniquePlugins[schemaName] = new Set();
          }

          if (Array.isArray(setUpPlugins[schemaName]))
          {
            setUpPlugins[schemaName].forEach(setUpPlugin =>
            {
              if (uniquePlugins[schemaName].has(setUpPlugin))
              {
                return;
              }

              nameToPlugins[schemaName].push(setUpPlugin.bind(null, app, setUpModule));
              uniquePlugins[schemaName].add(setUpPlugin);
            });
          }
          else
          {
            if (uniquePlugins[schemaName].has(setUpPlugins[schemaName]))
            {
              return;
            }

            nameToPlugins[schemaName].push(setUpPlugins[schemaName].bind(null, app, setUpModule));
            uniquePlugins[schemaName].add(setUpPlugins[schemaName]);
          }
        });
      }
    });

    const setUps = new Set();
    const setUpToName = new Map();

    module.modelsToLoad.forEach(({setUpModels}) =>
    {
      (Array.isArray(setUpModels) ? setUpModels : Object.values(setUpModels)).forEach((setUp) => setUps.add(setUp));
    });

    setUps.forEach(({name, setUp}) =>
    {
      setUpToName.set(setUp, name);

      const schema = setUp(app, module);

      if (!schema)
      {
        return;
      }

      nameToPlugins['*'].concat(nameToPlugins[name] || []).forEach(setUpPlugin =>
      {
        setUpPlugin(schema, {name});
      });

      module.model(name, schema);
    });

    module.modelsToLoad.forEach(({setUpModule, setUpModels}) =>
    {
      (Array.isArray(setUpModels) ? setUpModels : Object.values(setUpModels)).forEach(({setUp}) =>
      {
        const name = setUpToName.get(setUp);

        setUpModule[name] = module.model(name);
      });
    });

    module.modelsToLoad = [];

    module.info('Loaded models.', {modelCount: setUps.size});

    setImmediate(done);
  }

  function onAppStarted()
  {
    setUpKeepAliveQuery();
    dumpQueryCounter();
    setInterval(dumpQueryCounter, 3600 * 1000);
  }

  function setUpKeepAliveQuery()
  {
    if (!module.config.keepAliveQueryInterval)
    {
      return;
    }

    if (!module.connection.db)
    {
      return setTimeout(setUpKeepAliveQuery, module.config.keepAliveQueryInterval);
    }

    module.connection.db.stats((err, stats) =>
    {
      if (err)
      {
        if (!keepAliveFailed)
        {
          module.error(err, `Keep alive query failed.`);
        }

        keepAliveFailed = true;
      }
      else
      {
        if (keepAliveFailed)
        {
          module.info(`Kept alive.`, {stats});
        }

        keepAliveFailed = false;
      }

      setTimeout(setUpKeepAliveQuery, module.config.keepAliveQueryInterval);
    });
  }

  function setUpExpressMiddleware(message)
  {
    const expressModule = message.module;
    const expressApp = expressModule.app;

    expressApp.use(expressMiddleware.bind(null, app, module));
  }

  function dumpQueryCounter()
  {
    module.debug('Queries counted.', {queryCounter});
  }
};
